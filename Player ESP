local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")

local esp_table = {
    __loaded = false,
    main_settings = {
        textSize = 15,
        textFont = Drawing.Fonts.Monospace,
        distancelimit = false,
        maxdistance = 1000,
        useteamcolor = false,
        teamcheck = false,
        sleepcheck = false,
        simplecalc = true
    },
    settings = {
        enemy = {
            enabled = true,
            box = true,
            box_fill = true,
            realname = true,
            dist = true,
            weapon = true,
            skeleton = true,
            tracers = true, -- Tracer toggle
            box_outline = true,
            realname_outline = true,
            dist_outline = true,
            weapon_outline = true,
            box_color = { Color3.new(1, 1, 1), 1 },
            box_fill_color = { Color3.new(1, 0, 0), 0.3 },
            realname_color = { Color3.new(1, 1, 1), 1 },
            dist_color = { Color3.new(1, 1, 1), 1 },
            weapon_color = { Color3.new(1, 1, 1), 1 },
            skeleton_color = { Color3.new(1, 1, 1), 1 },
            tracer_color = { Color3.new(1, 1, 1), 1 }, 
            box_outline_color = { Color3.new(0, 0, 0), 1 },
            realname_outline_color = Color3.new(0, 0, 0),
            dist_outline_color = Color3.new(0, 0, 0),
            weapon_outline_color = Color3.new(0, 0, 0),
            chams = true,
            chams_visible_only = false,
            chams_fill_color = { Color3.new(1, 1, 1), 0.5 },
            chamsoutline_color = { Color3.new(1, 1, 1), 0 }
        }
    }
}

local container = Instance.new("Folder", CoreGui.RobloxGui)
container.Name = "ESPContainer"

local skeleton_order = {
    ["LeftFoot"] = "LeftLowerLeg", ["LeftLowerLeg"] = "LeftUpperLeg", ["LeftUpperLeg"] = "LowerTorso",
    ["RightFoot"] = "RightLowerLeg", ["RightLowerLeg"] = "RightUpperLeg", ["RightUpperLeg"] = "LowerTorso",
    ["LeftHand"] = "LeftLowerArm", ["LeftLowerArm"] = "LeftUpperArm", ["LeftUpperArm"] = "Torso",
    ["RightHand"] = "RightLowerArm", ["RightLowerArm"] = "RightUpperArm", ["RightUpperArm"] = "Torso",
    ["LowerTorso"] = "Torso", ["Torso"] = "Head"
}

local function worldToScreen(world)
    local screen, inBounds = Camera:WorldToViewportPoint(world)
    return Vector2.new(math.floor(screen.X), math.floor(screen.Y)), inBounds, screen.Z
end

local function calculateCornersSimple(head, hrp)
    local head_position = worldToScreen(head.Position - Vector3.new(0, 0.5, 0))
    local leg_position = worldToScreen(hrp.Position - Vector3.new(0, 3.5, 0))
    local headx, heady = head_position.X, head_position.Y
    local legx, legy = leg_position.X, leg_position.Y
    local height = legy - heady
    local width = height / 3.6
    return {
        topLeft = Vector2.new(headx - width, heady),
        topRight = Vector2.new(headx + width, heady),
        bottomLeft = Vector2.new(headx - width, legy),
        bottomRight = Vector2.new(headx + width, legy)
    }
end

local function getRainbowColor()
    local time = tick() * 0.5
    local r = (math.sin(time) + 1) / 2
    local g = (math.sin(time + 2 * math.pi / 3) + 1) / 2
    local b = (math.sin(time + 4 * math.pi / 3) + 1) / 2
    return Color3.new(r, g, b)
end

local loaded_plrs = {}
local esp = {
    create_obj = function(type, args)
        local obj = Drawing.new(type)
        for i, v in args do
            obj[i] = v
        end
        return obj
    end
}

local function create_player_esp(model)
    if not (model and model:FindFirstChild("Head") and model:FindFirstChild("LowerTorso")) then return end
    local settings = esp_table.settings.enemy
    loaded_plrs[model] = {
        obj = {
            box_fill = esp.create_obj("Square", { Filled = true, Visible = true }),
            box_outline = esp.create_obj("Square", { Filled = false, Thickness = 3, Visible = true, ZIndex = -1 }),
            box = esp.create_obj("Square", { Filled = false, Thickness = 1, Visible = true }),
            realname = esp.create_obj("Text", { Center = true, Visible = true }),
            dist = esp.create_obj("Text", { Center = true, Visible = true }),
            weapon = esp.create_obj("Text", { Center = true, Visible = true }),
            tracer = esp.create_obj("Line", { Thickness = 1, Visible = true })
        },
        chams_object = Instance.new("Highlight", container)
    }
    for required, _ in next, skeleton_order do
        loaded_plrs[model].obj["skeleton_" .. required] = esp.create_obj("Line", { Visible = true })
    end

    local character = model
    local head = model:FindFirstChild("Head")
    local lowertorso = model:FindFirstChild("LowerTorso")
    local plr = loaded_plrs[model]
    local obj = plr.obj
    local cham = plr.chams_object

    local function forceupdate()
        local rainbowColor = getRainbowColor()
        cham.DepthMode = settings.chams_visible_only and Enum.HighlightDepthMode.Occluded or Enum.HighlightDepthMode.AlwaysOnTop
        cham.FillColor = rainbowColor
        cham.FillTransparency = settings.chams_fill_color[2]
        cham.OutlineColor = rainbowColor
        cham.OutlineTransparency = settings.chamsoutline_color[2]

        obj.box.Transparency = settings.box_color[2]
        obj.box.Color = rainbowColor
        obj.box_outline.Transparency = settings.box_outline_color[2]
        obj.box_outline.Color = settings.box_outline_color[1]
        obj.box_fill.Color = rainbowColor
        obj.box_fill.Transparency = settings.box_fill_color[2]

        obj.realname.Size = esp_table.main_settings.textSize
        obj.realname.Font = esp_table.main_settings.textFont
        obj.realname.Color = rainbowColor
        obj.realname.Outline = settings.realname_outline
        obj.realname.OutlineColor = settings.realname_outline_color
        obj.realname.Transparency = settings.realname_color[2]

        obj.dist.Size = esp_table.main_settings.textSize
        obj.dist.Font = esp_table.main_settings.textFont
        obj.dist.Color = rainbowColor
        obj.dist.Outline = settings.dist_outline
        obj.dist.OutlineColor = settings.dist_outline_color
        obj.dist.Transparency = settings.dist_color[2]

        obj.weapon.Size = esp_table.main_settings.textSize
        obj.weapon.Font = esp_table.main_settings.textFont
        obj.weapon.Color = rainbowColor
        obj.weapon.Outline = settings.weapon_outline
        obj.weapon.OutlineColor = settings.weapon_outline_color
        obj.weapon.Transparency = settings.weapon_color[2]

        obj.tracer.Color = rainbowColor
        obj.tracer.Transparency = settings.tracer_color[2]

        cham.Enabled = settings.chams
        obj.box.Visible = settings.box
        obj.box_outline.Visible = settings.box_outline
        obj.box_fill.Visible = settings.box_fill
        obj.realname.Visible = settings.realname
        obj.dist.Visible = settings.dist
        obj.weapon.Visible = settings.weapon
        obj.tracer.Visible = settings.tracers

        for required, _ in next, skeleton_order do
            local skeletonobj = obj["skeleton_" .. required]
            if skeletonobj then
                skeletonobj.Color = rainbowColor
                skeletonobj.Transparency = settings.skeleton_color[2]
                skeletonobj.Visible = settings.skeleton
            end
        end
    end

    local function togglevis(bool)
        for _, v in obj do v.Visible = bool end
        cham.Enabled = bool and settings.chams
        for required, _ in next, skeleton_order do
            local skeletonobj = obj["skeleton_" .. required]
            if skeletonobj then
                skeletonobj.Visible = bool and settings.skeleton
            end
        end
    end

    plr.connection = RunService.RenderStepped:Connect(function()
        if not (head and character) then
            return togglevis(false)
        end
        local _, onScreen = worldToScreen(head.Position)
        if not onScreen then
            return togglevis(false)
        end

        local distance = (Camera.CFrame.Position - head.Position).Magnitude
        if esp_table.main_settings.distancelimit and distance > esp_table.main_settings.maxdistance then
            return togglevis(false)
        end

        togglevis(true)
        cham.Adornee = character
        forceupdate()

        local corners = calculateCornersSimple(head, lowertorso)
        if not corners then
            return togglevis(false)
        end

        local pos = corners.topLeft
        local size = corners.bottomRight - corners.topLeft
        obj.box.Position = pos
        obj.box.Size = size
        obj.box_outline.Position = pos + Vector2.new(1, 1)
        obj.box_outline.Size = size - Vector2.new(1, 1)
        obj.box_fill.Position = pos
        obj.box_fill.Size = size

        obj.realname.Text = Players:GetPlayerFromCharacter(character) and Players:GetPlayerFromCharacter(character).Name or "Player"
        obj.realname.Position = (corners.topLeft + corners.topRight) * 0.5 - Vector2.new(0, obj.realname.TextBounds.Y + 2)

        local bottom = (corners.bottomLeft + corners.bottomRight) * 0.5
        obj.dist.Text = tostring(math.round(distance)) .. " studs"
        obj.dist.Position = bottom
        obj.weapon.Text = "unknown"
        obj.weapon.Position = bottom + (obj.dist.Visible and Vector2.new(0, obj.dist.TextBounds.Y - 2) or Vector2.zero)

        if settings.skeleton then
            for _, part in next, character:GetChildren() do
                local skeletonobj = obj["skeleton_" .. part.Name]
                local parent_part = skeleton_order[part.Name] and character:FindFirstChild(skeleton_order[part.Name])
                if skeletonobj and parent_part then
                    local part_position, _ = Camera:WorldToViewportPoint(part.Position)
                    local parent_part_position, _ = Camera:WorldToViewportPoint(parent_part.CFrame.Position)
                    skeletonobj.From = Vector2.new(part_position.X, part_position.Y)
                    skeletonobj.To = Vector2.new(parent_part_position.X, parent_part_position.Y)
                end
            end
        end

        if settings.tracers then
            local torsoPos, onScreenTorso = worldToScreen(lowertorso.Position)
            if onScreenTorso then
                local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                obj.tracer.From = screenCenter
                obj.tracer.To = torsoPos
            else
                obj.tracer.Visible = false
            end
        end
    end)

    forceupdate()
end

local function destroy_esp(model)
    local plr_object = loaded_plrs[model]
    if not plr_object then return end
    plr_object.connection:Disconnect()
    for _, v in plr_object.obj do
        v:Remove()
    end
    if plr_object.chams_object then
        plr_object.chams_object:Destroy()
    end
    loaded_plrs[model] = nil
end

function esp_table.load()
    if esp_table.__loaded then return end
    for _, v in next, workspace:GetChildren() do
        create_player_esp(v)
    end
    esp_table.playerAdded = workspace.ChildAdded:Connect(create_player_esp)
    esp_table.playerRemoving = workspace.ChildRemoved:Connect(destroy_esp)
    esp_table.__loaded = true
end

function esp_table.unload()
    if not esp_table.__loaded then return end
    for _, v in next, workspace:GetChildren() do
        destroy_esp(v)
    end
    esp_table.playerAdded:Disconnect()
    esp_table.playerRemoving:Disconnect()
    esp_table.__loaded = false
end

esp_table.load()
